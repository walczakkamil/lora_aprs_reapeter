#include "stm32f1xx_hal.h"
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

/* =========================================================
   Piny wg Twojego projektu:
   SPI1: PA5 SCK, PA6 MISO, PA7 MOSI
   CS:   PA4
   RST:  PB0
   DIO0: PB1 (EXTI1)
   UART1: PA9 TX, PA10 RX
   LED:  PC13
   ========================================================= */

#define RX_NSS_GPIO_Port    GPIOA
#define RX_NSS_Pin          GPIO_PIN_4

#define RX_RST_GPIO_Port    GPIOB
#define RX_RST_Pin          GPIO_PIN_0

#define RX_DIO0_GPIO_Port   GPIOB
#define RX_DIO0_Pin         GPIO_PIN_1

#define LED_GPIO_Port       GPIOC
#define LED_Pin             GPIO_PIN_13

#define RX2_NSS_GPIO_Port   GPIOA
#define RX2_NSS_Pin         GPIO_PIN_3

#define RX2_RST_GPIO_Port   GPIOB
#define RX2_RST_Pin         GPIO_PIN_10

#define RX2_DIO0_GPIO_Port  GPIOB
#define RX2_DIO0_Pin        GPIO_PIN_11

SPI_HandleTypeDef hspi1;
UART_HandleTypeDef huart1;

static volatile uint8_t sx_rx_done = 0;

/* =========================
   USTAWIENIA LoRa – DOPASUJ DO IGATE
   =========================
   TTGO/Heltec iGate może używać różnych ustawień.
   Najczęściej spotykane dla “private LoRa” to:
   - SyncWord: 0x12
   - BW=125kHz, SF=7..12, CR=4/5, CRC ON
   - częstotliwość: np. 433.775 MHz (EU) lub 868.x
*/
#define RX_LORA_FREQ_HZ     434855000UL   // <-- zmień jeśli trzeba (np. 868100000)
#define RX_LORA_SYNCWORD    0x12          // <-- jeśli nie odbiera, spróbuj 0x34 (LoRaWAN) lub to co ma iGate
#define RX_LORA_BW_CR_EXPL  0x74          // BW=125kHz + CR=4/7 + Explicit
#define RX_LORA_SF_CRC      0x94          // SF9 + CRC ON
#define RX_LORA_MODEM_CFG3  0x04          // AGC AUTO ON

/* =========================
   UART log
   ========================= */
static void uart_puts(const char *s)
{
  HAL_UART_Transmit(&huart1, (uint8_t*)s, (uint16_t)strlen(s), 500);
}

static void uart_printf(const char *fmt, ...)
{
  char buf[256];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  uart_puts(buf);
}

/* =========================
   NSS / CS
   ========================= */
static inline void RX_NSS_LOW(void)  { HAL_GPIO_WritePin(RX_NSS_GPIO_Port, RX_NSS_Pin, GPIO_PIN_RESET); }
static inline void RX_NSS_HIGH(void) { HAL_GPIO_WritePin(RX_NSS_GPIO_Port, RX_NSS_Pin, GPIO_PIN_SET); }

static inline void RX2_NSS_LOW(void)  { HAL_GPIO_WritePin(RX2_NSS_GPIO_Port, RX2_NSS_Pin, GPIO_PIN_RESET); }
static inline void RX2_NSS_HIGH(void) { HAL_GPIO_WritePin(RX2_NSS_GPIO_Port, RX2_NSS_Pin, GPIO_PIN_SET); }

/* =========================
   Reset SX127x
   ========================= */
static void RX_Reset(void)
{
  HAL_GPIO_WritePin(RX_RST_GPIO_Port, RX_RST_Pin, GPIO_PIN_RESET);
  HAL_Delay(2);
  HAL_GPIO_WritePin(RX_RST_GPIO_Port, RX_RST_Pin, GPIO_PIN_SET);
  HAL_Delay(10);
}

static void RX2_Reset(void)
{
  HAL_GPIO_WritePin(RX2_RST_GPIO_Port, RX2_RST_Pin, GPIO_PIN_RESET);
  HAL_Delay(2);
  HAL_GPIO_WritePin(RX2_RST_GPIO_Port, RX2_RST_Pin, GPIO_PIN_SET);
  HAL_Delay(10);
}

/* =========================
   SPI reg read/write
   ========================= */
static uint8_t RX_ReadReg(uint8_t addr)
{
  uint8_t tx[2] = { (uint8_t)(addr & 0x7F), 0x00 };
  uint8_t rx[2] = { 0, 0 };

  RX_NSS_LOW();
  HAL_SPI_TransmitReceive(&hspi1, tx, rx, 2, 200);
  RX_NSS_HIGH();

  return rx[1];
}

static uint8_t RX2_ReadReg(uint8_t addr)
{
  uint8_t tx[2] = { (uint8_t)(addr & 0x7F), 0x00 };
  uint8_t rx[2] = { 0, 0 };

  RX2_NSS_LOW();
  HAL_SPI_TransmitReceive(&hspi1, tx, rx, 2, 200);
  RX2_NSS_HIGH();

  return rx[1];
}

static void RX_WriteReg(uint8_t addr, uint8_t value)
{
  uint8_t tx[2] = { (uint8_t)(addr | 0x80), value };

  RX_NSS_LOW();
  HAL_SPI_Transmit(&hspi1, tx, 2, 200);
  RX_NSS_HIGH();
}

static void RX2_WriteReg(uint8_t addr, uint8_t value)
{
  uint8_t tx[2] = { (uint8_t)(addr | 0x80), value };

  RX_NSS_LOW();
  HAL_SPI_Transmit(&hspi1, tx, 2, 200);
  RX_NSS_HIGH();
}

static void SX_ReadFifo(uint8_t *buf, uint8_t len)
{
  uint8_t addr = 0x00 & 0x7F; // FIFO read
  RX_NSS_LOW();
  HAL_SPI_Transmit(&hspi1, &addr, 1, 200);
  HAL_SPI_Receive(&hspi1, buf, len, 200);
  RX_NSS_HIGH();
}

/* =========================
   SX127x reg map
   ========================= */
#define REG_FIFO                0x00
#define REG_OP_MODE             0x01
#define REG_FRF_MSB             0x06
#define REG_FRF_MID             0x07
#define REG_FRF_LSB             0x08
#define REG_LNA                 0x0C
#define REG_FIFO_ADDR_PTR       0x0D
#define REG_FIFO_TX_BASE_ADDR   0x0E
#define REG_FIFO_RX_BASE_ADDR   0x0F
#define REG_FIFO_RX_CURRENT     0x10
#define REG_IRQ_FLAGS           0x12
#define REG_RX_NB_BYTES         0x13
#define REG_PKT_SNR_VALUE       0x19
#define REG_PKT_RSSI_VALUE      0x1A
#define REG_MODEM_CONFIG_1      0x1D
#define REG_MODEM_CONFIG_2      0x1E
#define REG_PREAMBLE_MSB        0x20
#define REG_PREAMBLE_LSB        0x21
#define REG_MODEM_CONFIG_3      0x26
#define REG_SYNC_WORD           0x39
#define REG_DIO_MAPPING_1       0x40
#define REG_VERSION             0x42

#define LONG_RANGE_MODE         0x80  // LoRa
#define MODE_SLEEP              0x00
#define MODE_STDBY              0x01
#define MODE_RX_CONTINUOUS      0x05

#define IRQ_RX_DONE             0x40
#define IRQ_PAYLOAD_CRC_ERROR   0x20

/* =========================
   LoRa helpers
   ========================= */
static void SX_SetMode(uint8_t mode)
{
  RX_WriteReg(REG_OP_MODE, LONG_RANGE_MODE | mode);
}

static void SX_SetFrequency_Hz(uint32_t hz)
{
  // FRF = (freq * 2^19) / 32e6 (dla 32 MHz w SX127x)
  uint64_t frf = ((uint64_t)hz << 19) / 32000000ULL;
  RX_WriteReg(REG_FRF_MSB, (uint8_t)(frf >> 16));
  RX_WriteReg(REG_FRF_MID, (uint8_t)(frf >> 8));
  RX_WriteReg(REG_FRF_LSB, (uint8_t)(frf >> 0));
}

static void SX_RX_LoRaRxInit(void)
{
  SX_SetMode(MODE_SLEEP);
  HAL_Delay(5);

  RX_WriteReg(REG_FIFO_TX_BASE_ADDR, 0x00);
  RX_WriteReg(REG_FIFO_RX_BASE_ADDR, 0x00);

  // LNA boost
  RX_WriteReg(REG_LNA, RX_ReadReg(REG_LNA) | 0x03);

  // SyncWord
  RX_WriteReg(REG_SYNC_WORD, RX_LORA_SYNCWORD);

  // Modem configs (dopasuj do iGate jeśli nie odbiera)
  RX_WriteReg(REG_MODEM_CONFIG_1, RX_LORA_BW_CR_EXPL);
  RX_WriteReg(REG_MODEM_CONFIG_2, RX_LORA_SF_CRC);
  RX_WriteReg(REG_MODEM_CONFIG_3, RX_LORA_MODEM_CFG3);

  // Preamble = 8
  RX_WriteReg(REG_PREAMBLE_MSB, 0x00);
  RX_WriteReg(REG_PREAMBLE_LSB, 0x08);

  // DIO0 = RxDone (DIO0 mapping bits = 00)
  uint8_t dmap1 = RX_ReadReg(REG_DIO_MAPPING_1);
  dmap1 &= 0x3F;
  RX_WriteReg(REG_DIO_MAPPING_1, dmap1);

  // clear IRQ
  RX_WriteReg(REG_IRQ_FLAGS, 0xFF);

  SX_SetMode(MODE_STDBY);
  HAL_Delay(5);
}

static void SX_RX_StartRxContinuous(void)
{
  RX_WriteReg(REG_IRQ_FLAGS, 0xFF);
  SX_SetMode(MODE_RX_CONTINUOUS);
}

static int16_t SX_ReadPacketRSSI_dBm(void)
{
  // HF (868/915): RSSI[dBm] ≈ -157 + value
  uint8_t v = RX_ReadReg(REG_PKT_RSSI_VALUE);
  return (int16_t)(-157 + (int16_t)v);
}

//static float SX_ReadPacketSNR_dB(void)
//{
//  int8_t v = (int8_t)RX_ReadReg(REG_PKT_SNR_VALUE);
//  return ((float)v) / 4.0f;
//}

/* =========================================================
   WAŻNE: Nie robimy EXTI1_IRQHandler tutaj!
   CubeMX ma to w stm32f1xx_it.c.
   Tu tylko callback z HAL.
   ========================================================= */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if (GPIO_Pin == RX_DIO0_Pin)
    sx_rx_done = 1;
}

/* =========================
   Init (samowystarczalne)
   ========================= */
static void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2; // 4 MHz
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;              // 36 MHz
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) while(1){}

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) while(1){}
}

static void MX_GPIO_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_AFIO_CLK_ENABLE();

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  // LED PC13
  GPIO_InitStruct.Pin = LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);
  HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);

  // CS PA4
  GPIO_InitStruct.Pin = RX_NSS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(RX_NSS_GPIO_Port, &GPIO_InitStruct);
  RX_NSS_HIGH();

  // RST PB0
  GPIO_InitStruct.Pin = RX_RST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(RX_RST_GPIO_Port, &GPIO_InitStruct);
  HAL_GPIO_WritePin(RX_RST_GPIO_Port, RX_RST_Pin, GPIO_PIN_SET);

  // DIO0 PB1 EXTI rising
  GPIO_InitStruct.Pin = RX_DIO0_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(RX_DIO0_GPIO_Port, &GPIO_InitStruct);

  // NVIC EXTI1
  HAL_NVIC_SetPriority(EXTI1_IRQn, 1, 0);
  HAL_NVIC_EnableIRQ(EXTI1_IRQn);

  // SPI1: PA5/PA7 AF_PP, PA6 input
  GPIO_InitStruct.Pin = GPIO_PIN_5 | GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_6;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  // UART1: PA9 TX AF_PP, PA10 RX input
  GPIO_InitStruct.Pin = GPIO_PIN_9;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);


  //TX
  // CS PA3
  GPIO_InitStruct.Pin = RX2_NSS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(RX2_NSS_GPIO_Port, &GPIO_InitStruct);
  RX2_NSS_HIGH();

  // RST TX PB10
  GPIO_InitStruct.Pin = RX2_RST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(RX2_RST_GPIO_Port, &GPIO_InitStruct);
  HAL_GPIO_WritePin(RX2_RST_GPIO_Port, RX2_RST_Pin, GPIO_PIN_SET);

  // DIO0_2 TX PB11
  GPIO_InitStruct.Pin = RX2_DIO0_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(RX2_DIO0_GPIO_Port, &GPIO_InitStruct);

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
}

static void MX_SPI1_Init(void)
{
  __HAL_RCC_SPI1_CLK_ENABLE();

  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; // wolno/stabilnie
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 7;

  if (HAL_SPI_Init(&hspi1) != HAL_OK) while(1){}
}

static void MX_USART1_UART_Init(void)
{
  __HAL_RCC_USART1_CLK_ENABLE();

  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK) while(1){}
}

/* =========================
   main
   ========================= */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART1_UART_Init();
  MX_SPI1_Init();

  uart_puts("\r\n=== LoRa RX START (SX127x) ===\r\n");

  RX_Reset();

  uint8_t ver = RX_ReadReg(REG_VERSION);
  uart_printf("RegVersion=0x%02X\r\n", ver);
  if (ver != 0x12) uart_puts("UWAGA: wersja inna niz 0x12\r\n");

  SX_RX_LoRaRxInit();
  SX_SetFrequency_Hz(RX_LORA_FREQ_HZ);

  uart_printf("RX Freq=%lu Hz, SyncWord=0x%02X\r\n", (unsigned long)RX_LORA_FREQ_HZ, (unsigned)RX_LORA_SYNCWORD);
  uart_puts("Start RX continuous...\r\n");

  SX_RX_StartRxContinuous();

  while (1)
  {
    if (sx_rx_done)
    {
      sx_rx_done = 0;

      uint8_t irq = RX_ReadReg(REG_IRQ_FLAGS);
      RX_WriteReg(REG_IRQ_FLAGS, 0xFF);

      if (irq & IRQ_PAYLOAD_CRC_ERROR)
      {
        uart_puts("RX: CRC ERROR\r\n");
        continue;
      }

      if (irq & IRQ_RX_DONE)
      {
        uint8_t cur = RX_ReadReg(REG_FIFO_RX_CURRENT);
        RX_WriteReg(REG_FIFO_ADDR_PTR, cur);

        uint8_t len = RX_ReadReg(REG_RX_NB_BYTES);
        if (len > 128) len = 128;

        uint8_t buf[128];
        memset(buf, 0, sizeof(buf));
        SX_ReadFifo(buf, len);

        int16_t rssi = SX_ReadPacketRSSI_dBm();
        //float snr = SX_ReadPacketSNR_dB();

        int8_t snr_q4 = (int8_t)RX_ReadReg(REG_PKT_SNR_VALUE); // *4
        int8_t snr_int = snr_q4 / 4;
        uint8_t snr_frac = (uint8_t)(snr_q4 & 0x03); // 0..3 => 0, .25, .5, .75

        uart_printf("RX DONE: len=%u RSSI=%ddBm SNR=%d.%s dB\r\n", len, rssi, snr_int, (snr_frac==0)?"00":(snr_frac==1)?"25":(snr_frac==2)?"50":"75");

        if (len > 3 && buf[0] == 0x3C && buf[1] == 0xFF && buf[2] == 0x01)
        {
          uart_puts("APRS: ");
          // drukuj od bajtu 3 do końca jako ASCII (zastępuj niedrukowalne kropką)
          for (uint8_t i = 3; i < len; i++)
          {
            uint8_t c = buf[i];
            if (c == '\r' || c == '\n' || c == '\t' || (c >= 0x20 && c <= 0x7E))
              HAL_UART_Transmit(&huart1, &c, 1, 100);
            else
            {
              uint8_t dot = '.';
              HAL_UART_Transmit(&huart1, &dot, 1, 100);
            }
          }
          uart_puts("\r\n");
        }
        else
        {
          // fallback do HEX
          uart_puts("DATA HEX: ");
          for (uint8_t i = 0; i < len; i++) uart_printf("%02X ", buf[i]);
          uart_puts("\r\n");
        }

        HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
      }
    }

    HAL_Delay(5);
  }
}
